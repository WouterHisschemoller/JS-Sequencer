/**
 * View is a layer between the HTML and the rest of the application.
 * It updates the view to represent the app state and 
 * passes DOM events generated by the user to the app.
 * 
 * @namespace WH
 */
window.WH = window.WH || {};

(function (WH) {

    /**
     * @constructor
     */
    function View() {

        // private variables
        var settings = {
                activeClass: 'is-active',
                selectedClass: 'is-selected',

                ctrlClass: '.ctrl',
                ctrlBackgroundClass: '.ctrl__background',
                ctrlHighlightClass: '.ctrl__hilight',
                ctrlLabelClass: '.ctrl__label',
                ctrlTextClass: '.ctrl__text',
                ctrlNameClass: '.ctrl__name',
                ctrlValueClass: '.ctrl__value',

                stepClass: '.step',

                channelClass: '.channel',
                channelSelectClass: '.channel__select',
                channelControlsClass: '.channel__controls',
                channelColorClasses: ['color1', 'color2', 'color3', 'color4'],

                rackClass: '.rack',
                rackGeneratorClass: '.rack__generator',

                pluginClass: '.plugin',
                pluginControlsClass: '.plugin__controls',

                tabClass: '.ctrl--tab',

                data: {
                    paramKey:  'param_key',
                    paramType: 'param_type',
                    pluginId: 'plugin_id'
                },

                ctrlTypes: {
                    generic: 'generic',
                    itemized: 'itemized',
                    boolean: 'boolean'
                },

                tabs: ['Sound', 'Mixer', 'Song', '']
            },

            /**
             * HTML elements.
             * @type {Object}
             */
            elements = {
                steps: null,
                stepsContainer: $('.steps'),
                stepTemplate: $('#template-step'),

                channels: null,
                channelContainer: $('.channels'),
                channelTemplate: $('#template-channel'),

                racks: null,
                rackContainer: $('.racks'),
                rackTemplate: $('#template-rack'),

                pluginTemplate: $('#template-plugin'),
                ctrlGenericTemplate: $('#template-ctrl-generic'),
                ctrlBooleanTemplate: $('#template-ctrl-boolean'),
                ctrlItemizedTemplate: $('#template-ctrl-itemized'),

                tabs: null,
                tabContainer: $('.tabs'),
                tabTemplate: $('#template-tab'),

                playStopButton: $('#play-control')
            },

            /**
             * Channel currently selected to view and edit.
             * @type {Number}
             */
            channelIndex = -1,

            /**
             * Reference to this once function has closed.
             */
            self = this,

            /**
             * Initialise the view, add DOM event handlers.
             */
            init = function() {

                if (!validateDomElements()) {
                    console.error('DOM elements invalid.');
                    return;
                }

                // create the step elements
                var i = 0,
                    n = WH.Settings.getStepCount(),
                    stepEl;
                for (i; i < n; i++) {
                    stepEl = elements.stepTemplate.children().first().clone();
                    stepEl.find(settings.ctrlTextClass).text(i + 1);
                    elements.stepsContainer.append(stepEl);
                }
                elements.steps = $(settings.stepClass);

                // create the channel elements
                var i = 0,
                    n = WH.Settings.getTrackCount(),
                    channelColor,
                    channelEl,
                    channelSelectEl,
                    channelControlsEl;

                for (i; i < n; i++) {
                    channelColor = settings.channelColorClasses[i];
                    channelEl = elements.channelTemplate.children().first().clone();
                    channelSelectEl = channelEl.find(settings.channelSelectClass);
                    channelSelectEl.find(settings.ctrlTextClass).text(String.fromCharCode(65 + i));
                    channelSelectEl.find(settings.ctrlBackgroundClass).addClass(channelColor);
                    channelSelectEl.find(settings.ctrlHighlightClass).addClass(channelColor);
                    elements.channelContainer.append(channelEl);
                }
                elements.channels = $(settings.channelClass);

                // create the plugin racks
                var i = 0,
                    n = WH.Settings.getTrackCount(),
                    rackEl,
                    generatorRackspaceEls,
                    generatorPluginEl;

                // create a rack for each channel
                for (i; i < n; i++) {
                    rackEl = elements.rackTemplate.children().first().clone();
                    elements.rackContainer.append(rackEl);
                }

                elements.racks = elements.rackContainer.find(settings.rackClass);

                // add an empty default generator plugin to each rack 
                generatorPluginEl = elements.pluginTemplate.children().first().clone();
                elements.racks.find(settings.rackGeneratorClass).append(generatorPluginEl);

                var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints,
                    eventType = isTouchDevice ? 'touchend' : 'click';

                // create tabs
                var i = 0,
                    n = settings.tabs.length,
                    tabEl;

                for (i; i < n; i++) {
                    tabEl = elements.tabTemplate.children().first().clone();
                    tabEl.find(settings.ctrlTextClass).text(settings.tabs[i]);
                    elements.tabContainer.append(tabEl);
                }

                elements.tabs = elements.tabContainer.find(settings.tabClass);
                
                // DOM event listeners
                elements.playStopButton.on(eventType, onPlayStopClick);
                elements.channels.find(settings.channelSelectClass).on(eventType, onChannelSelectClick);
                elements.channels.find(settings.channelControlsClass).on(eventType, onChannelControlsClick);
                elements.tabs.on(eventType, onTabClick);

                setSelectedChannel(0);
            },

            /**
             * Test is the correct DOM elements are present.
             * @return {Boolean} True if invalid.
             */
            validateDomElements = function() {

                var isValid = true;

                if (elements.playStopButton.length == 0) {
                    isValid = true;
                    console.error('No play button DOM element.');
                }

                return isValid;
            },

            /**
             * Play / Pause toggle button clicked.
             * @param  {Event} e Click event.
             */
            onPlayStopClick = function(e) {
                if (WH.TimeBase.isRunning()) {
                    WH.TimeBase.pause();
                    WH.TimeBase.rewind();
                    elements.playStopButton.removeClass(settings.activeClass);
                } else {
                    WH.TimeBase.start();
                    elements.playStopButton.addClass(settings.activeClass);
                }
            },

            /**
             * Tab button clicked.
             * @param  {Event} e Click event.
             */
            onTabClick = function(e) {

                var tabEl = $(e.currentTarget),
                    index = elements.tabs.index(tabEl),
                    isOpen = tabEl.hasClass(settings.selectedClass),
                    openTabs = elements.tabs.filter('.' + settings.selectedClass),
                    i = 0,
                    n = openTabs.length;

                for (i; i < n; i++) {
                    var tab = $(openTabs[i]),
                        tabIndex = elements.tabs.index(tab);
                    tab.removeClass(settings.selectedClass);
                    switch (tabIndex) {
                        case 1:
                            // close mixer
                            elements.channels.find(settings.channelControlsClass).slideUp();
                            break;
                    }
                }

                if (!isOpen) {
                    tabEl.addClass(settings.selectedClass);
                    switch (index) {
                        case 1:
                            // open mixer
                            elements.channels.find(settings.channelControlsClass).slideDown();
                            break;
                    }
                }
            },

            /**
             * Channel select button clicked.
             * @param  {Event} e Click event.
             */
            onChannelSelectClick = function(e) {
                var channel = $(e.target).closest(settings.channelClass),
                    index = elements.channels.index(channel);
                
                setSelectedChannel(index);
            }, 

            /**
             * One of the 
             * @param  {Event} e Click or touchend event, currentTarget it .ctrls container
             * @return {[type]}   [description]
             */
            onChannelControlsClick = function(e) {
                var controlEl = $(e.target).closest(settings.ctrlClass),
                    channelEl = controlEl.closest(settings.channelClass),
                    paramKey = controlEl.data(settings.data.paramKey),
                    paramType = controlEl.data(settings.data.paramType),
                    paramValue,
                    pluginId = channelEl.data(settings.data.pluginId)

                switch(paramType) {
                    case settings.ctrlTypes.boolean:
                        paramValue = !controlEl.hasClass(settings.selectedClass);
                        WH.Studio.setParameter(pluginId, paramKey, paramValue);
                        break;
                }
            },

            /**
             * Select a channel.
             * - Set selected channel button as selected.
             * - Show selected channel's instrument rack.
             * @param {Number} index Index of the channel to select.
             */
            setSelectedChannel = function(index) {
                if (index == channelIndex) {
                    return;
                }

                channelIndex = index;

                elements.channels.removeClass(settings.selectedClass);
                elements.channels.get(channelIndex).className += ' ' + settings.selectedClass;

                elements.racks.removeClass(settings.selectedClass)
                elements.racks.get(channelIndex).className += ' ' + settings.selectedClass;

                self.setSelectedSteps(channelIndex);
            },

            /**
             * Delay screen update to keep it synchronised with the audio.
             * @param  {Number} start Time to wait before update in milliseconds.
             * @param  {Array} activeSteps Steps that play in the current timespan. 
             */
            delayUpdateActiveSteps = function(start, activeSteps) {
                if (start > 0) {
                    setTimeout(function() {
                        updateActiveSteps(activeSteps);
                    }, start);
                } else {
                    updateActiveSteps(activeSteps);
                }
            },

            /**
             * Update the active step, this creates the 'running light' animation.
             * Also display flashing activity on the channel selectors.
             * @param  {Array} stepArray Steps that play in the current timespan. 
             */
            updateActiveSteps = function(stepArray) {
                var i = 0,
                    n = stepArray.length,
                    step;

                for (i; i < n; i++) {
                    step = stepArray[i];
                    
                    // update the steps
                    if (step.channel == channelIndex) {
                        elements.steps.removeClass(settings.activeClass);
                        $(elements.steps[step.index]).addClass(settings.activeClass);
                        $(elements.steps[step.index])
                            .find(settings.ctrlHighlightClass)
                                .show()
                                .stop()
                                .fadeIn(0)
                                .fadeOut(300);
                    }

                    // update the channels
                    if (step.velocity > 0) {
                        $(elements.channels[step.channel])
                            .find(settings.channelSelectClass + ' > ' + settings.ctrlHighlightClass)
                                .show()
                                .stop()
                                .fadeIn(0)
                                .fadeOut(300);
                    }
                }
            },

            addControls = function(plugin, containerEl) {

                var paramKey,
                    param,
                    paramValue,
                    paramType,
                    controlEl,
                    hasEditableCheck = typeof plugin.isEditableParam == 'function';
                
                // add controls
                for (paramKey in plugin.params) {

                    // only render parameters that are allowed to by the plugin
                    if (hasEditableCheck && !plugin.isEditableParam(paramKey) ) {
                        continue;
                    }

                    param = plugin.params[paramKey];
                    paramValue = param.value;

                    switch (param.type) {
                        case 'Generic':
                            paramValue = paramValue.toFixed(1);
                            controlEl = elements.ctrlGenericTemplate.children().first().clone();
                            controlEl.find(settings.ctrlNameClass).text(param.name);
                            controlEl.find(settings.ctrlValueClass).text(paramValue);
                            paramType = settings.ctrlTypes.generic;
                            break;
                        case 'Itemized':
                            paramValue = WX.findKeyByValue(param.getModel(), paramValue);
                            controlEl = elements.ctrlItemizedTemplate.children().first().clone();
                            controlEl.find(settings.ctrlNameClass).text(param.name);
                            controlEl.find(settings.ctrlValueClass).text(paramValue);
                            paramType = settings.ctrlTypes.itemized;
                            break;
                        case 'Boolean':
                            controlEl = elements.ctrlBooleanTemplate.children().first().clone();
                            controlEl.find(settings.ctrlTextClass).text(param.name);
                            if (paramValue) {
                                controlEl.addClass(settings.selectedClass);
                            }
                            paramType = settings.ctrlTypes.boolean;
                            break;
                    }
                    
                    controlEl.attr('data-' + settings.data.paramKey, paramKey);
                    controlEl.attr('data-' + settings.data.paramType, paramType);
                    containerEl.append(controlEl);
                }
            };

        /**
         * Receive Step objects during playback to update the view with.
         * @param  {Array} playbackQueue Array of Step objects.
         */
        this.onStepEvents = function(playbackQueue) {
            var i = 0,
                n = playbackQueue.length,
                step,
                start,
                stepArray = [],
                oldStart = -1;

            for (i; i < n; i++) {
                step = playbackQueue[i];
                start = Math.max(0, WX.now - step.absStart) * 1000;

                if (start != oldStart && stepArray.length > 0) {
                    delayUpdateActiveSteps(oldStart, stepArray);
                    stepArray = [];
                }

                stepArray.push(step);
                oldStart = start;
            }

            delayUpdateActiveSteps(oldStart, stepArray);
        };

        /**
         * Update the pattern to show selected steps.
         * Typically after switching patterns or tracks.
         * @param {Number} index Channel / track index.
         */
        this.setSelectedSteps = function(index) {
            var steps = WH.Project.getTrackSteps(index),
                id,
                i = 0,
                n = settings.channelColorClasses.length,
                channelColorClass = settings.channelColorClasses[index];

            // remove color classes
            for (i; i < n; i++) {
                elements.steps.find(settings.ctrlBackgroundClass).removeClass(settings.channelColorClasses[i]);
                elements.steps.find(settings.ctrlHighlightClass).removeClass(settings.channelColorClasses[i]);
            }

            // set selected state
            elements.steps.removeClass(settings.selectedClass);
            for (var id in steps) {
                var step = steps[id];
                if(step.velocity) {
                    var $step = $(elements.steps[step.index]);
                    $step.addClass(settings.selectedClass);
                    $step.find(settings.ctrlBackgroundClass).addClass(channelColorClass);
                    $step.find(settings.ctrlHighlightClass).addClass(channelColorClass);
                }
            }
        };

        /**
         * Fill a mixer channel with mixer channel controls.
         * This happens once because the mixer is created only once.
         * @param {Object} channel WX.PlugIn Processor object.
         * @param {Number} index Channel index in which to create the channel controls.
         */
        this.setChannel = function(channel, index) {
            
            var channelEl = $(elements.channels[index]),
                controlsEl = channelEl.find(settings.channelControlsClass);

            // set plugin id on channel element
            channelEl.attr('data-' + settings.data.pluginId, channel.getId());
            
            addControls(channel, controlsEl);
            controlsEl.find(settings.ctrlBackgroundClass).addClass(settings.channelColorClasses[index]);
            controlsEl.find(settings.ctrlHighlightClass).addClass(settings.channelColorClasses[index]);
        };

        /**
         * Set the instrument controls,
         * typically after project initialisation or channel switch.
         * @param {Object} instrument WX.PlugIn Generator object.
         * @param {Number} index Rack index in which to set the instrument.
         */
        this.setInstrument = function(instrument, index) {

            var rack = $(elements.racks[index]),
                generatorRack = rack.find(settings.rackGeneratorClass),
                controlsEl = generatorRack.find(settings.pluginControlsClass);

            // remove the old generator controls
            controlsEl.empty();
            addControls(instrument, controlsEl);
            controlsEl.find(settings.ctrlBackgroundClass).addClass(settings.channelColorClasses[index]);
        };

        /**
         * Update a control to reflect a changed plugin parameter.
         * @param  {Number} pluginId Unique ID of the plugin.
         * @param  {String} paramKey The parameter to change.
         * @param  {Number, String or Boolean} paramValue The new value for the parameter.
         */
        this.updateControl = function(pluginId, paramKey, paramValue) {
            var pluginEl = $('[data-' + settings.data.pluginId + '="' + pluginId + '"]'),
                ctrlEl = pluginEl.find(settings.ctrlClass + '[data-' + settings.data.paramKey + '="' + paramKey + '"]')
                ctrlType = ctrlEl.data(settings.data.paramType);

            switch (ctrlType) {
                case settings.ctrlTypes.generic:
                    break;
                case settings.ctrlTypes.itemized:
                    break;
                case settings.ctrlTypes.boolean:
                    ctrlEl.toggleClass(settings.selectedClass, paramValue);
                    break;
            }
        }

        // initialise
        init();
    }
    
    /** 
     * Singleton
     */
    WH.View = new View();
})(WH);