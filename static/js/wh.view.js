/**
 * View is a layer between the HTML and the rest of the application.
 * It updates the view to represent the app state and 
 * passes DOM events generated by the user to the app.
 * 
 * @namespace WH
 */
window.WH = window.WH || {};

(function (WH) {

    /**
     * @constructor
     */
    function View() {

        // private variables
        var settings = {
                channelClass: '.channel',
                channelSelectClass: '.channel__select',
                channelControlsClass: '.channel__controls',

                rackClass: '.rack',
                rackGeneratorContainerClass: '.rack__generator',

                pluginClass: '.plugin',
                pluginHeaderClass: '.plugin__header',
                pluginNameClass: '.plugin__name-label',
                pluginControlsClass: '.plugin__controls',

                data: {
                    pluginId: 'plugin_id'
                },

                tabs: ['Sound', 'Mixer', 'Song', ''],

                transport: ['Play']
            },

            /**
             * HTML elements.
             * @type {Object}
             */
            elements = {
                channels: null,
                channelContainer: $('.channels'),
                channelTemplate: $('#template-channel'),

                racks: null,
                rackContainer: $('.racks'),
                rackTemplate: $('#template-rack'),

                transportContainer: $('.transport'),
                pluginTemplate: $('#template-plugin'),
                pluginHeaderTemplate: $('#template-plugin-header'),
                tabContainer: $('.tabs'),

                pluginTemplates: {
                    WXS1: $('#template-plugin-wxs1')
                }
            },

            /**
             * Channel currently selected to view and edit.
             * @type {Number}
             */
            channelIndex = -1,

            /**
             * Reference to this once function has closed.
             * @type {Object}
             */
            self = this,

            /**
             * ControlsView creates UI controls.
             * @type {Object}
             */
            controls = null,

            /**
             * StepsView creates sequencer steps UI controls.
             * @type {Object}
             */
            steps = null,

            /**
             * Initialise the view, add DOM event handlers.
             */
            init = function() {

                controls = WH.ControlsView();

                steps = WH.StepsView();

                // create the channel elements
                var i = 0,
                    n = WH.Conf.getTrackCount(),
                    channelEl;

                for (i; i < n; i++) {
                    // create channel element
                    channelEl = elements.channelTemplate.children().first().clone();
                    elements.channelContainer.append(channelEl);
                }
                elements.channels = $(settings.channelClass);

                // create channel select controls.
                var channelSelectContainers = elements.channelContainer.find(settings.channelSelectClass);
                controls.addChannelSelectControls(channelSelectContainers, settings.channelColorClasses);

                // create the plugin racks
                var i = 0,
                    n = WH.Conf.getTrackCount(),
                    rackEl,
                    generatorRackspaceEls,
                    generatorPluginEl;

                // create a rack for each channel
                for (i; i < n; i++) {
                    rackEl = elements.rackTemplate.children().first().clone();
                    elements.rackContainer.append(rackEl);
                }

                elements.racks = elements.rackContainer.find(settings.rackClass);

                // create tabs
                elements.tabs = controls.addTabControls(elements.tabContainer, settings.tabs);

                // create transport buttons
                controls.addTransportControls(elements.transportContainer, settings.transport);

                self.setSelectedChannel(0);
                self.setSelectedTab(0);
            };

            /**
             * Delay screen update to keep it synchronised with the audio.
             * @param  {Number} start Time to wait before update in milliseconds.
             * @param  {Array} activeSteps Steps that play in the current timespan. 
             */
            delayUpdateSequencerActivity = function(start, activeSteps) {
                if (start > 0) {
                    setTimeout(function() {
                        updateSequencerActivity(activeSteps);
                    }, start);
                } else {
                    updateSequencerActivity(activeSteps);
                }
            },

            /**
             * Update the active step, this creates the 'running light' animation.
             * Also display flashing activity on the channel selectors.
             * @param  {Array} stepArray Steps that play in the current timespan. 
             */
            updateSequencerActivity = function(stepArray) {
                var i = 0,
                    n = stepArray.length,
                    step,
                    stepEl;

                for (i; i < n; i++) {
                    step = stepArray[i];
                    
                    // update the steps
                    if (step.channel == channelIndex) {
                        steps.updateActiveStep(step.index);
                    }

                    // update the channels
                    if (step.velocity > 0) {
                        self.animateHighlight($(elements.channels[step.channel]).find(settings.channelSelectClass));
                    }
                }
            };

        /**
         * Receive Step objects during playback to update the view with.
         * @param  {Array} playbackQueue Array of Step objects.
         */
        this.onSequencerEvents = function(playbackQueue) {
            var i = 0,
                n = playbackQueue.length,
                step,
                start,
                stepArray = [],
                oldStart = -1;

            for (i; i < n; i++) {
                step = playbackQueue[i];
                start = Math.max(0, WX.now - step.absStart) * 1000;

                if (start != oldStart && stepArray.length > 0) {
                    delayUpdateSequencerActivity(oldStart, stepArray);
                    stepArray = [];
                }

                stepArray.push(step);
                oldStart = start;
            }

            delayUpdateSequencerActivity(oldStart, stepArray);
        };

        /**
         * Set a tab as selected and update the view state..
         * @param {Number} index Index of the tab to select.
         */
        this.setSelectedTab = function(index) {
            var tabEl = $(elements.tabs[index]);
                isOpen = tabEl.hasClass(settings.selectedClass),
                openTabs = elements.tabs.filter('.' + settings.selectedClass),
                i = 0,
                n = openTabs.length;

            for (i; i < n; i++) {
                var tab = $(openTabs[i]),
                    tabIndex = elements.tabs.index(tab);
                tab.removeClass(settings.selectedClass);
                switch (tabIndex) {
                    case 0:
                        // close instrument
                        elements.rackContainer.slideUp();
                        break;
                    case 1:
                        // close mixer
                        elements.channels.find(settings.channelControlsClass).slideUp();
                        break;
                }
            }

            if (!isOpen) {
                tabEl.addClass(settings.selectedClass);
                switch (index) {
                    case 0:
                        // open instrument
                        elements.rackContainer.slideDown();
                        break;
                    case 1:
                        // open mixer
                        elements.channels.find(settings.channelControlsClass).slideDown();
                        break;
                }
            }
        };

        /**
         * Select a channel.
         * - Set selected channel button as selected.
         * - Show selected channel's instrument rack.
         * @param {Number} index Index of the channel to select.
         */
        this.setSelectedChannel = function(index) {
            if (index == channelIndex) {
                return;
            }

            channelIndex = index;

            elements.channels.removeClass(settings.selectedClass);
            elements.channels.get(channelIndex).className += ' ' + settings.selectedClass;

            elements.racks.removeClass(settings.selectedClass);
            elements.racks.get(channelIndex).className += ' ' + settings.selectedClass;

            this.setSelectedSteps();
        };

        /**
         * Update the pattern to show selected steps.
         * Typically after switching patterns or tracks.
         * @param {Number} index Channel / track index.
         */
        this.setSelectedSteps = function(index) {
            index = isNaN(index) ? channelIndex : index;
            steps.setSelected(index);
        };

        /**
         * Fill a mixer channel with mixer channel controls.
         * This happens once because the mixer is created only once.
         * @param {Object} channel WX.PlugIn Processor object.
         * @param {Number} index Channel index in which to create the channel controls.
         */
        this.setChannel = function(channel, index) {
            var channelEl = $(elements.channels[index]),
                controlsEl = channelEl.find(settings.channelControlsClass);

            channelEl.attr('data-' + settings.data.pluginId, channel.getId());
            controls.addControls(controlsEl, channel);
            controls.setColor(controlsEl, settings.channelColorClasses[index]);
        };

        /**
         * Set the instrument controls,
         * typically after project initialisation or channel switch.
         * @param {Object} instrument WX.PlugIn Generator object.
         * @param {Number} index Rack index in which to set the instrument.
         */
        this.setInstrument = function(instrument, index) {
            var rackEl = $(elements.racks[index]),
                generatorContainerEl = rackEl.find(settings.rackGeneratorContainerClass),
                pluginEl,
                headerEl,
                controlsEl,
                pluginTemplate = elements.pluginTemplates[instrument.info.className];

            pluginEl = pluginTemplate.children().first().clone();
            pluginEl.appendTo(generatorContainerEl);
            pluginEl.attr('data-' + settings.data.pluginId, instrument.getId());

            headerEl = elements.pluginHeaderTemplate.children().first().clone();
            headerEl.prependTo(pluginEl);
            headerEl.find(settings.pluginNameClass).text(instrument.info.name);
            this.setColor(pluginEl.find(settings.pluginHeaderClass), settings.channelColorClasses[index]);
            
            controlsEl = pluginEl.find(settings.pluginControlsClass);
            controls.addPluginControls(controlsEl, instrument);
            this.setColor(controlsEl, settings.channelColorClasses[index]);
        };

        /**
         * Update a control to reflect a changed plugin parameter.
         * @param {Number} pluginId Unique ID of the plugin.
         * @param {String} paramKey The parameter to change.
         * @param {Object} paramValues Object containing all the values of the parameter.
         */
        this.updatePluginControl = function(pluginId, paramKey, paramValues) {
            var pluginEl = $('[data-' + settings.data.pluginId + '="' + pluginId + '"]');
            controls.updateControl(pluginEl, paramKey, paramValues);
        };

        /**
         * Apply a plugin preset to the plugin with the provided ID.
         * @param {Number} pluginId Unique lugin ID.
         * @param {Array} presetValues Plugin preset as array of objects with key value pairs.
         */
        this.setPluginPreset =  function(pluginId, presetValues) {
            var paramKey,
                paramValues;
            
            for (paramKey in presetValues) {
                paramValues = presetValues[paramKey];
                if (paramValues.isEditable) {
                    this.updatePluginControl(pluginId, paramKey, paramValues);
                }
            }
        };

        // extend AbstractView
        WH.AbstractView.call(this, settings);

        // initialise
        init();
    }
    
    /** 
     * Singleton
     */
    WH.View = new View();
})(WH);
